---
title: "Two_stage_2.0"
author: "Anna Boser"
date: "7/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)

library(cvTools)
library(dplyr)
library(tidyr)
library(lme4)
library(spgwr)
library(leaps)
library(sp)
library(GWmodel)
```

## Two-stage model creation and testing narrative

I load in my data and set the Day as a factor. 
```{r load_data}
Data <- read.csv(file = "C:\\Users\\aboser\\Documents\\GitHub\\PM_prediction\\Data\\Final_DFs\\Train.csv")

#make day factor for random effects
Data$Day <- as.factor(Data$Day)
```

The idea here is you train it on the full set, you test it on the small subset, and then you apply it to the subsetted grid. 


There are a few days missing BLH, so I get rid of those. Given that there are many missing AOD values, I separate the data into data with and without AOD/BLH and train models on both. The data that has AOD is trained and tested on the same data, but the data without the AOD is trained on the full dataset, except instead of the AOD value it has an indicator as to whether AOD is present, and then the training data is just the data without AOD with a column indicating that there is no AOD. 

Required datasets: 

For days with AOD: 
1) Training data with AOD
2) Grid containing days with AOD
For days without AOD: 
3) Full training set with indicator as to whether AOD is around
4) Grid containing days without AOD and indicator indicating the missing AOD

Outputs needed: 
- R2 (and other metric) values from this split model, only AOD model, and no AOD model (depending on AOD presence) at each of the training sites (larger grid) for interpolation and mapping purposes.
- Metric averages for split model, only AOD model, and no AOD model over the smaller grid
- full map of modeled values on smaller grid

#training data
```{r filter_data}
Data <- filter(Data, !is.na(BLH))
w_AOD <- filter(Data, !is.na(AOD)) #1
# wo_AOD <- filter(Data, is.na(AOD)) 
# wo_AOD$AOD <- 0
indfunc <- function(val){
  if (is.na(val)){
    return(0)
  } else {
    return(1)
  }
}
ind_AOD <- Data
ind_AOD$AOD <- unlist(lapply(ind_AOD$AOD, indfunc)) #3
```

CV showed that this reduced formula, obtained through BIC analysis, performs better than the full model.
```{r LME_formula}
LME_formula <- "PM ~ Elevation + 
                      Emissions +
                      Forest +
                      Streets +
                      Plumes_High +
                      Plumes_Med +
                      Plumes_Low +
                      Max_Temp +
                      Max_Wind +
                      Rel_Humidity +
                      BLH +
                      AOD +
                      (1 + 
                         Plumes_High +
                      Plumes_Med +
                      Plumes_Low +
                      Max_Temp +
                      Max_Wind +
                      Rel_Humidity +
                      BLH +
                      AOD| Day)"
```

```{r}
GWR_formula <- "resid ~ AOD + 
                      Elevation + 
                      Emissions +
                      Streets +
                      Plumes_High +
                      Plumes_Med +
                      Plumes_Low +
                      Max_Temp +
                      Max_Wind +
                      Rel_Humidity +
                      BLH"
```


```{r R2_function}
R2 <- function(prediction, true){
  (sum(
    (prediction - mean(prediction))
    *(true - mean(true))
    )/
      (sqrt(
        sum(
          (prediction - mean(prediction)
          )^2))*
         sqrt(
           sum(
             ((true - mean(true))^2)))
       ))^2
}

NSE <- function(prediction, true){
  1 - (sum((prediction - true)^2)/sum((true - mean(true))^2))
}

Bias <- function(prediction, true){
  mean(prediction - true)
}

MAE <- function(prediction, true){
  mean(abs(prediction - true))
}

MSE <- function(prediction, true){
  mean((prediction - true)^2)
}

RMSE <- function(prediction, true){
  sqrt(mean((prediction - true)^2))
}
```

```{r CV_2_stage}
CV <- function(AOD_Data, wo_AOD_Data, lme_formula, gwr_formula, bwAOD = NA, bw_woAOD = NA){

# make folds based on location Id
folds <- unique(AOD_Data$Id)
paste0("Folds = k = ", length(folds))

#parameters I want to save after each fold
w_AOD_prediction <- c()
w_AOD_true <- c()

wo_AOD_prediction <- c()
wo_AOD_true <- c()

w_AOD_df <- as.data.frame(matrix(data = NA, nrow = length(folds) + 1, ncol = 7))
wo_AOD_df <- as.data.frame(matrix(data = NA, nrow = length(folds) + 1, ncol = 7))
All_df <- as.data.frame(matrix(data = NA, nrow = length(folds) + 1, ncol = 7))

names(w_AOD_df) <- c("station", "MAE", "MSE", "RMSE", "NSE", "Bias", "R2")
names(wo_AOD_df) <- c("station", "MAE", "MSE", "RMSE", "NSE", "Bias", "R2")
names(All_df) <- c("station", "MAE", "MSE", "RMSE", "NSE", "Bias", "R2")

#loop through the folds and fit/test the full model each time.
for(i in 1:length(folds)){
  # The way the two-stage model is broken down: 
  # 1: use the training data to fit a linear mixed effects model
  # 2: using the training data, predict the PM using the LME and calculate the residuals
  # 3: use the training data residuals to fit the GWR model on the residuals (actual - predicted) from the LME model
  # 4: use the test data to predict the PM with the LME model and the residuals from the LME model using the GWR model
  # 5: add the gwr-predicted residuals to the lme-predicted PM values to obtain the final prediction. 
  
  train_AOD <- filter(AOD_Data, Id != folds[i])
  train_wo_AOD <- filter(wo_AOD_Data, Id != folds[i]) #train on all with indicator
  
  test_AOD <- filter(AOD_Data, Id == folds[i], Day %in% unique(train_AOD$Day)) #make sure you trained on the days
  test_wo_AOD <- filter(wo_AOD_Data, Id == folds[i], AOD == 0, Day %in% unique(train_wo_AOD$Day)) #test on only days missing AOD; make sure you trained on the days
  
  # 1:
  AOD_lme <- lmer(formula = lme_formula, 
                 data = train_AOD)
  wo_AOD_lme <- lmer(formula = lme_formula, 
                 data = train_wo_AOD)
  
  # 2:
  train_AOD$resid <- train_AOD$PM - predict(AOD_lme) #training residuals
  AOD_lme_predictions <- predict(AOD_lme, newdata = test_AOD) #testing predictions
  
  train_wo_AOD$resid <- train_wo_AOD$PM - predict(wo_AOD_lme) #training residuals
  wo_AOD_lme_predictions <- predict(wo_AOD_lme, newdata = test_wo_AOD) #testing predictions
  
  # 3 and 4: 
  
  #convert train and test data to sp for easier use in spgwr
  train_sp_AOD <- SpatialPointsDataFrame(coords = cbind(train_AOD$Lon, train_AOD$Lat), data = train_AOD, proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
  test_sp_AOD <- SpatialPointsDataFrame(coords = cbind(test_AOD$Lon, test_AOD$Lat), data = test_AOD, proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
  
  train_sp_wo_AOD <- SpatialPointsDataFrame(coords = cbind(train_wo_AOD$Lon, train_wo_AOD$Lat), data = train_wo_AOD, proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
  test_sp_wo_AOD <- SpatialPointsDataFrame(coords = cbind(test_wo_AOD$Lon, test_wo_AOD$Lat), data = test_wo_AOD, proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
  
  if (is.na(bwAOD)){
    gwr.bw.AOD <- gwr.sel(gwr_formula, data = train_sp_AOD, longlat = TRUE)
    gwr_model_AOD <- gwr(gwr_formula, data = train_sp_AOD, bandwidth = gwr.bw.AOD, longlat = TRUE, fit.points = test_sp_AOD, predictions = TRUE)
  
    gwr.bw.wo.AOD <- gwr.sel(gwr_formula, data = train_sp_wo_AOD, longlat = TRUE)
    gwr_model_wo_AOD <- gwr(gwr_formula, data = train_sp_wo_AOD, bandwidth = gwr.bw.wo.AOD, longlat = TRUE, fit.points = test_sp_wo_AOD, predictions = TRUE)
  } else {
    gwr_model_AOD <- gwr(gwr_formula, data = train_sp_AOD, bandwidth = bwAOD, longlat = TRUE, fit.points = test_sp_AOD, predictions = TRUE)
    
    gwr_model_wo_AOD <- gwr(gwr_formula, data = train_sp_wo_AOD, bandwidth = bw_woAOD, longlat = TRUE, fit.points = test_sp_wo_AOD, predictions = TRUE)
  }

  gwr_resid_AOD <- gwr_model_AOD$SDF$pred
  gwr_resid_wo_AOD <- gwr_model_wo_AOD$SDF$pred
  
  AOD_test_predictions <- gwr_resid_AOD + AOD_lme_predictions
  wo_AOD_test_predictions <- gwr_resid_wo_AOD + wo_AOD_lme_predictions
  
  update_df <- function(df, i, id, test_pred, actual){
    df$station[i] <- id
    df$MAE[i] <- MAE(test_pred, actual)
    df$MSE[i] <- MSE(test_pred, actual)
    df$Bias[i] <- Bias(test_pred, actual) 
    df$RMSE[i] <- RMSE(test_pred, actual)
    df$R2[i] <- R2(test_pred, actual)
    df$NSE[i] <- NSE(test_pred, actual)
    return(df)
  }
  
  
  w_AOD_df <- update_df(w_AOD_df, i, folds[i], AOD_test_predictions, test_AOD$PM)
  wo_AOD_df <- update_df(wo_AOD_df, i, folds[i], wo_AOD_test_predictions, test_wo_AOD$PM)
  All_df <- update_df(All_df, i, folds[i], c(AOD_test_predictions, AOD_test_predictions), c(test_AOD$PM, test_wo_AOD$PM))
  
  w_AOD_prediction <- c(w_AOD_prediction, AOD_test_predictions)
  w_AOD_true <- c(w_AOD_true, test_AOD$PM)

  wo_AOD_prediction <- c(wo_AOD_prediction, wo_AOD_test_predictions)
  wo_AOD_true <- c(wo_AOD_true, test_wo_AOD$PM)
}
w_AOD_df <- update_df(w_AOD_df, length(folds) + 1, "All", w_AOD_prediction, w_AOD_true)
wo_AOD_df <- update_df(wo_AOD_df, length(folds) + 1, "All", wo_AOD_prediction, wo_AOD_true)
All_df <- update_df(All_df, "All", length(folds) + 1, c(w_AOD_prediction, wo_AOD_prediction), c(w_AOD_true, wo_AOD_true))

return(list(w_AOD_df, wo_AOD_df, All_df))
}
```

```{r}
CV <- CV(AOD_Data = w_AOD, wo_AOD_Data = ind_AOD, lme_formula = LME_formula, gwr_formula = GWR_formula, bwAOD = 15.21389, bw_woAOD = 13.15854)
```


#test data (full grid)
```{r}
Grid <- read.csv(file = "C:\\Users\\aboser\\Documents\\GitHub\\PM_prediction\\Data\\Final_DFs\\Small_Grid.csv") #missing BLH already removed
Grid_w_AOD <- filter(Grid, !is.na(AOD)) #2
Grid_wo_AOD <- filter(Grid, is.na(AOD)) #4
Grid_wo_AOD$AOD <- 0
rm(Grid)
```


Training the model
```{r}
Fit_to_grid <- function(lme_formula, gwr_formula, train_AOD, train_wo_AOD, test_AOD, test_wo_AOD, bw = NA){
# The way the two-stage model is broken down: 
  # 1: use the training data to fit a linear mixed effects model
  # 2: using the training data, predict the PM using the LME and calculate the residuals
  # 3: use the training data residuals to fit the GWR model on the residuals (actual - predicted) from the LME model
  # 4: use the test data to predict the PM with the LME model and the residuals from the LME model using the GWR model
  # 5: add the gwr-predicted residuals to the lme-predicted PM values to obtain the final prediction. 
  
  test_AOD <- filter(test_AOD, Day %in% unique(train_AOD$Day))
  test_wo_AOD <- filter(test_wo_AOD, Day %in% unique(train_wo_AOD$Day))
  
  # 1:
  AOD_lme <- lmer(formula = lme_formula, 
                 data = train_AOD)
  wo_AOD_lme <- lmer(formula = lme_formula, 
                 data = train_wo_AOD)
  
  print("LME trained")
  
  # 2:
  train_AOD$resid <- train_AOD$PM - predict(AOD_lme) #training residuals
  AOD_lme_predictions <- predict(AOD_lme, newdata = test_AOD) #testing predictions
  
  train_wo_AOD$resid <- train_wo_AOD$PM - predict(wo_AOD_lme) #training residuals
  wo_AOD_lme_predictions <- predict(wo_AOD_lme, newdata = test_wo_AOD) #testing predictions
  
  print("LME predictions and residuals calculated")
  
  # 3 and 4: 
  
  #convert train and test data to sp for easier use in spgwr
  train_sp_AOD <- SpatialPointsDataFrame(coords = cbind(train_AOD$Lon, train_AOD$Lat), data = train_AOD, proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
  test_sp_AOD <- SpatialPointsDataFrame(coords = cbind(test_AOD$Lon, test_AOD$Lat), data = test_AOD, proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
  
  train_sp_wo_AOD <- SpatialPointsDataFrame(coords = cbind(train_wo_AOD$Lon, train_wo_AOD$Lat), data = train_wo_AOD, proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
  test_sp_wo_AOD <- SpatialPointsDataFrame(coords = cbind(test_wo_AOD$Lon, test_wo_AOD$Lat), data = test_wo_AOD, proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
  
  print("Data converted to sp objects")
  
  if (is.na(bw)){
    gwr.bw.AOD <- gwr.sel(gwr_formula, data = train_sp_AOD, longlat = TRUE)
    gwr_model_AOD <- gwr(gwr_formula, data = train_sp_AOD, bandwidth = gwr.bw.AOD, longlat = TRUE, fit.points = test_sp_AOD, predictions = TRUE)
  
    gwr.bw.wo.AOD <- gwr.sel(gwr_formula, data = train_sp_wo_AOD, longlat = TRUE)
    gwr_model_wo_AOD <- gwr(gwr_formula, data = train_sp_wo_AOD, bandwidth = gwr.bw.wo.AOD, longlat = TRUE, fit.points = test_sp_wo_AOD, predictions = TRUE)
  } else {
    gwr_model_AOD <- gwr(gwr_formula, data = train_sp_AOD, bandwidth = bw, longlat = TRUE, fit.points = test_sp_AOD, predictions = TRUE)
    
    gwr_model_wo_AOD <- gwr(gwr_formula, data = train_sp_wo_AOD, bandwidth = bw, longlat = TRUE, fit.points = test_sp_wo_AOD, predictions = TRUE)
  }

  print("GWR model finished")
  
  gwr_resid_AOD <- gwr_model_AOD$SDF$pred
  gwr_resid_wo_AOD <- gwr_model_wo_AOD$SDF$pred
  
  AOD_test_predictions <- gwr_resid_AOD + AOD_lme_predictions
  wo_AOD_test_predictions <- gwr_resid_wo_AOD + wo_AOD_lme_predictions
  
  test_AOD$pred <- AOD_test_predictions
  test_wo_AOD$pred <- wo_AOD_test_predictions
  
  print("predictions calculated")
  
  full_grid <- rbind(test_AOD, test_wo_AOD)
  full_grid <- arrange(full_grid, Id, Day)
  full_grid <- select(full_grid, Id, Day, pred)
  full_grid <- pivot_wider(full_grid, names_from = Day, names_prefix = "Day", values_from = "pred")
  
  return(full_grid)
}
```

```{r}
Full_grid <- Fit_to_grid(lme_formula = LME_formula, gwr_formula = GWR_formula, train_AOD = w_AOD, train_wo_AOD = ind_AOD, test_AOD = Grid_w_AOD, test_wo_AOD = Grid_wo_AOD, bw = NA)
```

```{r}
write.csv(Full_grid, file = "C:\\Users\\aboser\\Documents\\GitHub\\PM_prediction\\Data\\Final_DFs\\Two-stage_Grid.csv", row.names = FALSE)
```



